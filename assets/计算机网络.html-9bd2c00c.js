import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as d,f as r}from"./app-131d0148.js";const n={},a=r(`<h1 id="计算机网络-http、tcp" tabindex="-1"><a class="header-anchor" href="#计算机网络-http、tcp" aria-hidden="true">#</a> 计算机网络（HTTP、TCP）</h1><h2 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h2><p>主要特点：简单快速、灵活、<strong>无连接</strong>、<strong>无状态</strong></p><p>http报文包括：<strong>请求报文</strong>和<strong>响应报文</strong></p><figure><img src="http://img.smyhvae.com/20180306_1400.png" alt="http报文" tabindex="0" loading="lazy"><figcaption>http报文</figcaption></figure><p>方法：GET、POST、PUT、DELETE、HEAD</p><h3 id="get与post区别" tabindex="-1"><a class="header-anchor" href="#get与post区别" aria-hidden="true">#</a> <strong>GET与POST区别</strong></h3><p>1、浏览器在回退时，get<strong>不会重新请求</strong>，但是post会重新请求。✔️</p><p>2、get请求会被浏览器<strong>主动缓存</strong>，而post不会。✔️</p><p>3、get请求的参数，会报<strong>保留</strong>在浏览器的<strong>历史记录</strong>里，而post不会。为了防止CSRF攻击，很多公司把get统一改成了post。✔️</p><p>4、get请求在url中传递的参数有大小限制，基本是2kb，不同的浏览器略有不同。而post没有。</p><p>5、get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。</p><p>6、参数的数据类型，GET只接受ASCII字符，POST无限制。</p><hr><h3 id="http-状态码" tabindex="-1"><a class="header-anchor" href="#http-状态码" aria-hidden="true">#</a> HTTP 状态码</h3><table><thead><tr><th><strong>分类</strong></th><th><strong>分类描述</strong></th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到 1** 类型的状态码）</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><table><thead><tr><th style="text-align:center;"><strong>状态码</strong></th><th><strong>状态码英文名称</strong></th><th style="text-align:center;"><strong>中文描述</strong></th></tr></thead><tbody><tr><td style="text-align:center;">200</td><td>OK</td><td style="text-align:center;">请求成功。一般用于 GET 与 POST 请求</td></tr><tr><td style="text-align:center;">201</td><td>Created</td><td style="text-align:center;">已创建。成功请求并创建了新的资源，通常用于 POST 或 PUT 请求</td></tr><tr><td style="text-align:center;">301</td><td>Moved Permanently</td><td style="text-align:center;">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td style="text-align:center;">302</td><td>Found</td><td style="text-align:center;">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td style="text-align:center;">304</td><td>Not Modified</td><td style="text-align:center;">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。</td></tr></tbody></table><table><thead><tr><th><strong>状态码</strong></th><th><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td>400</td><td>Bad Request</td><td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。</td></tr><tr><td>401</td><td>Unauthorized</td><td>当前请求需要用户验证。</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器已经理解请求，但是拒绝执行它。</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。</td></tr><tr><td>408</td><td>Request Timeout</td><td>请求超时。服务器等待客户端发送的请求时间过长，超时。</td></tr></tbody></table><table><thead><tr><th><strong>状态码</strong></th><th><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求。</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持该请求方法，无法完成请求。只有 GET 和 HEAD 请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。</td></tr></tbody></table><h3 id="http-和-https-的区别及优缺点✔️" tabindex="-1"><a class="header-anchor" href="#http-和-https-的区别及优缺点✔️" aria-hidden="true">#</a> http 和 https 的区别及优缺点✔️</h3><ul><li>http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议<code>安全</code>，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。</li><li>http 协议的默认端口为 <strong>80</strong>，https 的默认端口为 443。</li><li>http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li><li>https 缓存不如 http 高效，会增加数据开销。</li><li>Https 协议需要 <strong>CA证书</strong>，费用较高。</li><li>SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。</li></ul><h3 id="持久链接-http长连接-了解" tabindex="-1"><a class="header-anchor" href="#持久链接-http长连接-了解" aria-hidden="true">#</a> 持久链接/http长连接（了解）</h3><ul><li><p><strong>轮询</strong>：http1.0中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。</p></li><li><p><strong>长连接</strong>：HTTP1.1中，通过使用Connection:keep-alive进行长连接。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。</p></li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><p>HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对<strong>每个请求仍然要单独发 header</strong>，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p></div><h3 id="长连接中的管线化" tabindex="-1"><a class="header-anchor" href="#长连接中的管线化" aria-hidden="true">#</a> 长连接中的管线化</h3><p>长连接时，<strong>默认</strong>的请求这样的：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>	请求1 --&gt; 响应1 --&gt;请求2 --&gt; 响应2 --&gt; 请求3 --&gt; 响应3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>长连接中的管线化：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>	请求1 --&gt; 请求2 --&gt; 请求3 --&gt; 响应1 --&gt; 响应2 --&gt; 响应3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>管线化:把现在的请求打包，一次性发过去，最后再一次性响应回来。</p><h2 id="tcp和udp的区别" tabindex="-1"><a class="header-anchor" href="#tcp和udp的区别" aria-hidden="true">#</a> TCP和UDP的区别</h2><ol><li>TCP是面向链接的，而UDP是面向无连接的。</li><li>TCP仅支持<strong>单播传输</strong>，UDP 提供了单播，多播，广播的功能。</li><li>TCP的三次握手保证了连接的<strong>可靠性</strong>；UDP是<strong>无连接的、不可靠的</strong>一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</li><li>UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好。</li></ol>`,32),s=[a];function o(i,h){return e(),d("div",null,s)}const p=t(n,[["render",o],["__file","计算机网络.html.vue"]]);export{p as default};
