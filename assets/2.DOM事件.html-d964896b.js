import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as e,f as s}from"./app-131d0148.js";const t={},i=s(`<h1 id="dom" tabindex="-1"><a class="header-anchor" href="#dom" aria-hidden="true">#</a> DOM</h1><h2 id="获取页面中元素的方式" tabindex="-1"><a class="header-anchor" href="#获取页面中元素的方式" aria-hidden="true">#</a> 获取页面中元素的方式</h2><ol><li><p>根据 ID 获取：<code>var ele = document.getElementById(&#39;#id&#39;);</code></p></li><li><p>根据标签名获取：<code>var ele = document.getElementsByTagName(&#39;div&#39;);</code></p><ul><li><p>返回的是获取过来元素对象的集合,以伪数组的形式存储的</p></li><li><p><code>console.log(ele[0])</code> 打印 div 标签列表第一个元素</p></li></ul></li><li><p>根据类名返回元素对象集合：<code>document.getElementsByClassName(‘类名’)；</code></p></li><li><p>根据指定选择器返回第一个元素对象：<code>document.querySelector(&#39;选择器&#39;);</code></p></li><li><p>根据指定选择器返回：<code>document.querySelectorAll(&#39;选择器&#39;);</code></p></li></ol><div class="hint-container warning"><p class="hint-container-title">注意</p><ol><li><p>querySelector 和 querySelectorAll 里面的选择器需要加符号,比如:document.querySelector(&#39;#nav&#39;);</p></li><li><p>获取 body 元素：<code>var bodyEle = document.body;</code></p></li><li><p>获取 html 元素：<code>var htmlEle = document.documentElement;</code></p></li></ol></div><h2 id="创建元素" tabindex="-1"><a class="header-anchor" href="#创建元素" aria-hidden="true">#</a> 创建元素</h2><p>三种动态创建元素：</p><ul><li><p>document.write()</p></li><li><p>element.innerHTML</p></li><li><p>document.createElement()</p></li></ul><div class="hint-container info"><p class="hint-container-title">区别</p><ol><li><p>document.write 是直接将内容写入页面的内容流，但是文档流执行完毕，则它会<mark>导致页面全部重绘</mark></p></li><li><p>innerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘</p></li><li><p>innerHTML 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂</p></li><li><p>createElement() 创建多个元素效率稍低一点点，但是结构更清晰<br> 总结：不同浏览器下，innerHTML 效率要比 creatElement 高</p></li></ol></div><h2 id="dom-事件" tabindex="-1"><a class="header-anchor" href="#dom-事件" aria-hidden="true">#</a> DOM 事件</h2><p><strong>DOM0</strong>：element.onclick=function(){}</p><p><strong>DOM2</strong>:<code>element.addEventListener(&#39;click&#39;,function(){}, false); </code>false 代表事件在<strong>冒泡阶段</strong>触发（默认）</p><p><strong>DOM3</strong>：<code>element.addEventListener(&#39;keyup&#39;, function () {}, false);</code>增加其他事件类型，比如鼠标事件、键盘事件</p><h2 id="事件模型-捕获-当前目标阶段-冒泡" tabindex="-1"><a class="header-anchor" href="#事件模型-捕获-当前目标阶段-冒泡" aria-hidden="true">#</a> 事件模型：捕获-&gt;当前目标阶段-&gt;冒泡</h2><ul><li>捕获：从上往下。</li><li>冒泡：从下（目标元素）往上。</li></ul><figure><img src="http://img.smyhvae.com/20180306_1058.png" alt="事件流" tabindex="0" loading="lazy"><figcaption>事件流</figcaption></figure><div class="hint-container warning"><p class="hint-container-title">注意</p><ol><li>JS 代码中只能执行捕获或者冒泡其中的一个阶段。</li><li>onclick 和 attachEvent 只能得到冒泡阶段。</li><li>addEventListener第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false（不写默认就是 false），表示在事件冒泡阶段调用事件处理程序。</li><li>有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave</li></ol></div><figure><img src="http://img.smyhvae.com/20180204_1218.jpg" alt="原型图" tabindex="0" loading="lazy"><figcaption>原型图</figcaption></figure><figure><img src="http://img.smyhvae.com/20180306_1103.png" alt="层级" tabindex="0" loading="lazy"><figcaption>层级</figcaption></figure><h4 id="event-对象及常见-api-方法" tabindex="-1"><a class="header-anchor" href="#event-对象及常见-api-方法" aria-hidden="true">#</a> Event 对象及常见 api 方法</h4><ol><li><code>event.preventDefault();</code>阻止默认事件</li><li><code>event.stopPropagation();</code> <code>event.cancelBubble = true;</code>阻止冒泡</li><li><code>event.stopImmediatePropagation();</code>设置事件优先级</li><li><code>event.currentTarget </code> 当前所绑定的事件对象。在事件委托中，指的是【父元素】</li><li><code>event.target</code> 当前被点击的元素。在事件委托中，指的是【子元素】</li></ol><div class="hint-container info"><p class="hint-container-title">e.target 和 this 的区别</p><p>this 是事件<mark>绑定</mark>的元素， 这个函数的调用者（绑定这个事件的元素）</p><p>e.target 是事件<mark>触发</mark>的元素。</p></div><h4 id="自定义事件" tabindex="-1"><a class="header-anchor" href="#自定义事件" aria-hidden="true">#</a> 自定义事件</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> myEvent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Event</span><span class="token punctuation">(</span><span class="token string">&quot;clickTest&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;clickTest&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;smyhvae&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//元素注册事件</span>
element<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>myEvent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注意，参数是写事件对象 myEvent，不是写 事件名 clickTest</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="事件代理-委派" tabindex="-1"><a class="header-anchor" href="#事件代理-委派" aria-hidden="true">#</a> 事件代理（委派）</h4><p>原理：事件委托是利用了冒泡机制，减少了事件绑定的次数，减少内存消耗和 DOM 操作，提高性能。动态绑定事件。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
        <span class="token comment">// 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点</span>
        <span class="token keyword">var</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&#39;ul&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ul<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// alert(&#39;知否知否，点我应有弹框在手！&#39;);</span>
            <span class="token comment">// e.target 这个可以得到我们点击的对象</span>
            e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">&#39;blue&#39;</span><span class="token punctuation">;</span>
              <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,26),o=[i];function c(l,p){return a(),e("div",null,o)}const u=n(t,[["render",c],["__file","2.DOM事件.html.vue"]]);export{u as default};
