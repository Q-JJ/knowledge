import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as r,c as n,b as e,e as o,w as a,d,f as i}from"./app-131d0148.js";const h={},p=e("h1",{id:"vue",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue","aria-hidden":"true"},"#"),d(" Vue")],-1),u=e("h2",{id:"mvvm",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#mvvm","aria-hidden":"true"},"#"),d(" MVVM")],-1),s=e("h2",{id:"生命周期",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#生命周期","aria-hidden":"true"},"#"),d(" 生命周期")],-1),v=i('<h2 id="computed与watch" tabindex="-1"><a class="header-anchor" href="#computed与watch" aria-hidden="true">#</a> computed与watch</h2><p>既能用 computed 实现又可以用 watch 监听来实现的功能，推荐用 computed。<br> 重点在于 computed 的缓存功能， computed 计算属性是用来声明式的描述一个值依赖了其它的值，当所依赖的值或者变量改变时，计算属性也会跟着改变；computed会自动计算更新<br> watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。watch不会有缓存</p><p><strong>使用场景</strong></p><p><code>computed</code>：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能</p><p><code>watch</code>：当一条数据影响多条数据的时候使用，例：搜索数据</p><h2 id="nexttick" tabindex="-1"><a class="header-anchor" href="#nexttick" aria-hidden="true">#</a> nextTick</h2><ol><li>语法：<code>this.$nextTick(回调函数)</code></li></ol><div class="hint-container info"><p class="hint-container-title">本质</p><p>对 JavaScript 执行原理 EventLoop 的一种应用。 nextTick是将回调函数放到一个异步队列中，保证在异步更新DOM的watcher后面，从而获取到更新后的DOM。</p></div><ol start="2"><li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li><li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li></ol><h2 id="vue组件的通信方式" tabindex="-1"><a class="header-anchor" href="#vue组件的通信方式" aria-hidden="true">#</a> vue组件的通信方式</h2><ul><li><p><code>props</code>/<code>$emit</code> 父子组件通信</p><p>父-&gt;子<code>props</code>，子-&gt;父 <code>$on、$emit</code> 获取父子组件实例 <code>parent、children</code> <code>Ref </code>获取实例的方式调用组件的属性或者方法 父-&gt;子孙 <code>Provide、inject</code> 官方不推荐使用，但是写组件库时很常用</p></li><li><p><code>$emit</code>/<code>$on</code> 自定义事件 兄弟组件通信</p><p><code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue()</code> 自定义事件</p></li><li><p>vuex 跨级组件通信</p><p>Vuex、<code>$attrs、$listeners</code> <code>Provide、inject</code></p></li><li><p>slot 插槽<br> 专门实现父向子组件通信</p></li><li><p>provied和inject</p></li></ul><h2 id="keep-alive的实现" tabindex="-1"><a class="header-anchor" href="#keep-alive的实现" aria-hidden="true">#</a> keep-alive的实现</h2><p>作用：将不活动的组件实例保存在内存中，实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。</p><p>场景：tabs标签页、后台导航，vue性能优化</p><p>原理：<code>Vue.js</code>内部将<code>DOM</code>节点抽象成了一个个的<code>VNode</code>节点，<code>keep-alive</code>组件的缓存也是基于<code>VNode</code>节点的而不是直接存储<code>DOM</code>结构。它将满足条件<code>（pruneCache与pruneCache）</code>的组件在<code>cache</code>对象中缓存起来，在需要重新渲染的时候再将<code>vnode</code>节点从<code>cache</code>对象中取出并渲染。</p><h2 id="vuex" tabindex="-1"><a class="header-anchor" href="#vuex" aria-hidden="true">#</a> Vuex</h2>',16),E=i('<h2 id="vue的性能优化" tabindex="-1"><a class="header-anchor" href="#vue的性能优化" aria-hidden="true">#</a> Vue的性能优化</h2><ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><li>v-if和v-for不能连用，如果需要使用v-for给每项元素绑定事件时使用事件代理</li><li>SPA 页面采用keep-alive缓存组件</li><li>在更多的情况下，使用v-if替代v-show</li><li>key保证唯一</li><li>使用路由懒加载、异步组件</li><li>防抖、节流</li><li>第三方模块按需导入</li><li>图片懒加载</li><li>使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li><li>使用cdn加载第三方模块</li><li>SEO优化</li><li>预渲染</li><li>服务端渲染SSR</li></ul>',2);function m(f,x){const c=l("RouterLink");return r(),n("div",null,[p,u,e("p",null,[o(c,{to:"/qianduan/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Vue/%E5%9F%BA%E7%A1%80%E7%AF%87/Vue.html"},{default:a(()=>[d("MVVM")]),_:1})]),s,e("p",null,[o(c,{to:"/qianduan/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Vue/%E5%9F%BA%E7%A1%80%E7%AF%87/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"},{default:a(()=>[d("生命周期")]),_:1})]),v,e("p",null,[o(c,{to:"/qianduan/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Vue/3.Vuex/%E4%BB%8B%E7%BB%8D.html"},{default:a(()=>[d("Vuex")]),_:1})]),E])}const A=t(h,[["render",m],["__file","Vue.html.vue"]]);export{A as default};
