const t=JSON.parse('{"key":"v-9018d038","path":"/qianduan/%E5%9F%BA%E7%A1%80/JS/6.var__let__const.html","title":"var && let && const","lang":"zh-CN","frontmatter":{"order":6,"headerDepth":3,"date":"2022-07-23T00:00:00.000Z","readingTime":"N/A","word":"N/A","lastUpdated":true,"article":false,"description":"var &amp;&amp; let &amp;&amp; const 区别 var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。存在变量提升 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。不存在变量提升 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。 var可以先使用，后声明，因为存在变量提升；let必须先声明后使用。 var是允许在相同作用域内重复声明同一个变量的，而let与const不允许这一现象。 在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ;var声明的变量会和GO有映射关系； 会产生暂时性死区","head":[["meta",{"property":"og:url","content":"https://q-jj.github.io/knowledge/knowledge/qianduan/%E5%9F%BA%E7%A1%80/JS/6.var__let__const.html"}],["meta",{"property":"og:site_name","content":"湫的知识海洋"}],["meta",{"property":"og:title","content":"var && let && const"}],["meta",{"property":"og:description","content":"var &amp;&amp; let &amp;&amp; const 区别 var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。存在变量提升 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。不存在变量提升 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。 var可以先使用，后声明，因为存在变量提升；let必须先声明后使用。 var是允许在相同作用域内重复声明同一个变量的，而let与const不允许这一现象。 在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ;var声明的变量会和GO有映射关系； 会产生暂时性死区"}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-29T03:52:20.000Z"}],["meta",{"property":"article:author","content":"Yivn"}],["meta",{"property":"article:published_time","content":"2022-07-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-29T03:52:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"var && let && const\\",\\"description\\":\\"var &amp;&amp; let &amp;&amp; const 区别 var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。存在变量提升 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。不存在变量提升 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。 var可以先使用，后声明，因为存在变量提升；let必须先声明后使用。 var是允许在相同作用域内重复声明同一个变量的，而let与const不允许这一现象。 在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ;var声明的变量会和GO有映射关系； 会产生暂时性死区\\"}"]]},"headers":[{"level":2,"title":"区别","slug":"区别","link":"#区别","children":[]}],"git":{"createdTime":1703821940000,"updatedTime":1703821940000,"contributors":[{"name":"Q-JJ","email":"J001222@163.com","commits":1}]},"readingTime":{"minutes":0.98,"words":295},"filePathRelative":"qianduan/基础/JS/6.var&&let&&const.md","localizedDate":"2022年7月23日","excerpt":"<h1> var &amp;&amp; let &amp;&amp; const</h1>\\n<h2> 区别</h2>\\n<ol>\\n<li>\\n<p>var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。存在变量提升</p>\\n</li>\\n<li>\\n<p>let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。不存在变量提升</p>\\n</li>\\n<li>\\n<p>const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，且不能修改。</p>\\n</li>\\n<li>\\n<p>var可以<code>先使用，后声明</code>，因为存在变量提升；let必须先声明后使用。</p>\\n</li>\\n<li>\\n<p>var是允许在相同作用域内重复声明同一个变量的，而let与const不允许这一现象。</p>\\n</li>\\n<li>\\n<p>在全局上下文中，基于let声明的全局变量和全局对象GO（window）没有任何关系 ;var声明的变量会和GO有映射关系；</p>\\n</li>\\n<li>\\n<p><code>会产生暂时性死区</code></p>\\n</li>\\n</ol>","autoDesc":true}');export{t as data};
