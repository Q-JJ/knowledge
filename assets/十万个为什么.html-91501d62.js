import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as r,f as i}from"./app-131d0148.js";const d={},o=i('<h1 id="十万个为什么" tabindex="-1"><a class="header-anchor" href="#十万个为什么" aria-hidden="true">#</a> 十万个为什么</h1><h2 id="data为什么是一个函数而不是对象" tabindex="-1"><a class="header-anchor" href="#data为什么是一个函数而不是对象" aria-hidden="true">#</a> data为什么是一个函数而不是对象</h2><p>因为对象是一个引用类型，如果data是一个对象的情况下会造成多个组件共用一个data，data为一个函数，每个组件都会有自己的私有数据空间，不会干扰其他组件的运行。</p><h2 id="为什么不建议用index作为key" tabindex="-1"><a class="header-anchor" href="#为什么不建议用index作为key" aria-hidden="true">#</a> 为什么不建议用index作为key?</h2><p>如果将数组下标作为<code>key</code>值，那么当列表发生变化时，可能会导致<code>key</code>值发生改变，从而引发不必要的组件重新渲染，甚至会导致性能问题。例如，当删除列表中某个元素时，其后面的所有元素的下标都会发生改变，导致<code>Vue</code>重新渲染整个列表。</p><h2 id="为什么v-for中建议带-key-有什么情况下是可以不带的" tabindex="-1"><a class="header-anchor" href="#为什么v-for中建议带-key-有什么情况下是可以不带的" aria-hidden="true">#</a> 为什么<code>v-for</code>中建议带<code>:key</code>，有什么情况下是可以不带的？</h2><h2 id="为什么v-for和v-if不建议用在一起" tabindex="-1"><a class="header-anchor" href="#为什么v-for和v-if不建议用在一起" aria-hidden="true">#</a> 为什么v-for和v-if不建议用在一起</h2><p>当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。这样会造成很大的性能浪费。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>3.x 版本中 v-if 总是优先于 v-for 生效</p></div><p>组件或者插件吗，有什么注意点？</p><ul><li><code>vue-router</code>原理是什么</li></ul><p>你知道的设计模式有哪些，知道他们的应用场景吗（解决了什么问题），Vue中用了哪些设计模式</p><p>React/Vue 项目中 key 的作用</p><p>key的作用是为了在diff算法执行时更快的找到对应的节点，提高diff速度，更高效的更新虚拟DOM;<br> vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。</p><p>为了在数据变化时强制更新组件，以避免“就地复用”带来的副作用。<br> 当 Vue.js 用 v-for 更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。重复的key会造成渲染错误。</p><p>浏览器重绘与重排的区别？</p><p>重排/回流（Reflow）：当DOM的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。<br> 重绘(Repaint): 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变</p><p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分<br> 重排和重绘代价是高昂的，它们会破坏用户体验，并且让UI展示非常迟缓，而相比之下重排的性能影响更大，在两者无法避免的情况下，一般我们宁可选择代价更小的重绘。<br> 『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。<br> 如何触发重排和重绘？<br> 任何改变用来构建渲染树的信息都会导致一次重排或重绘：</p><p>添加、删除、更新DOM节点<br> 通过display: none隐藏一个DOM节点-触发重排和重绘<br> 通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化<br> 移动或者给页面中的DOM节点添加动画<br> 添加一个样式表，调整样式属性<br> 用户行为，例如调整窗口大小，改变字号，或者滚动。</p><p>如何避免重绘或者重排？</p><p>集中改变样式，不要一条一条地修改 DOM 的样式。</p><p>不要把 DOM 结点的属性值放在循环里当成循环里的变量。</p><p>为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。</p><p>不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。</p><p>尽量只修改position：absolute或fixed元素，对其他元素影响不大</p><p>动画开始GPU加速，translate使用3D变化</p>',26),t=[o];function p(n,c){return a(),r("div",null,t)}const s=e(d,[["render",p],["__file","十万个为什么.html.vue"]]);export{s as default};
