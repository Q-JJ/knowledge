import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as a,f as e}from"./app-131d0148.js";const t="/knowledge/assets/image-b49ac994.png",p={},o=e(`<h1 id="类型兼容性" tabindex="-1"><a class="header-anchor" href="#类型兼容性" aria-hidden="true">#</a> 类型兼容性</h1><p>将只有一个传入参数赋值给需3个参数的函数，并没有报错，因为发生了类型兼容。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code> <span class="token keyword">let</span> arr<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
 arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// arr.forEach((item, index) =&gt; {})</span>
<span class="token comment">// arr.forEach((item, index, array) =&gt; {})</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+t+`" alt="回调函数类型兼容" tabindex="0" loading="lazy"><figcaption>回调函数类型兼容</figcaption></figure><p>以下代码并不会报错误</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>    <span class="token comment">// A 和 B是不同的类</span>
    <span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span><span class="token punctuation">{</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span>y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">}</span>
    <span class="token keyword">class</span> <span class="token class-name"><span class="token constant">B</span></span><span class="token punctuation">{</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span>y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">}</span>
    <span class="token comment">// C为A类型，但是是B的实例</span>
    <span class="token keyword">const</span> <span class="token constant">C</span><span class="token operator">:</span><span class="token constant">A</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">B</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原因：TS 是结构化类型系统<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup>，只检查A和B的结构是否相同，都有x,y属性且类型相同。（java是标明类型系统，这样写会报错）</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>    <span class="token comment">// 同样，成员多的可以赋值给少的</span>
    <span class="token keyword">class</span> <span class="token class-name"><span class="token constant">A</span></span><span class="token punctuation">{</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span>y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">}</span>
    <span class="token keyword">class</span> <span class="token class-name"><span class="token constant">D</span></span><span class="token punctuation">{</span>x<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span>y<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">,</span>z<span class="token operator">:</span><span class="token builtin">number</span><span class="token punctuation">}</span>
    <span class="token comment">// C为A类型，但是是D的实例</span>
    <span class="token keyword">const</span> <span class="token constant">C</span><span class="token operator">:</span><span class="token constant">A</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">D</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="接口兼容性" tabindex="-1"><a class="header-anchor" href="#接口兼容性" aria-hidden="true">#</a> 接口兼容性</h2><p>和class兼容性类似，interface可以和class兼容。</p><div class="language-typescript line-numbers-mode" data-ext="ts"><pre class="language-typescript"><code>    <span class="token comment">// 接口</span>
    <span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">E</span></span> <span class="token punctuation">{</span>x<span class="token operator">:</span> <span class="token builtin">number</span> y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span>
    <span class="token comment">// 类</span>
    <span class="token keyword">class</span> <span class="token class-name"><span class="token constant">F</span></span> <span class="token punctuation">{</span>x<span class="token operator">:</span> <span class="token builtin">number</span> y<span class="token operator">:</span> numberz<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span>
    <span class="token comment">// 类和接口之间也是兼容的</span>
    <span class="token constant">C</span><span class="token operator">:</span><span class="token constant">E</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name"><span class="token constant">F</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="函数兼容性" tabindex="-1"><a class="header-anchor" href="#函数兼容性" aria-hidden="true">#</a> 函数兼容性</h2><p>参数数量、参数类型、返回值类型</p><ol><li>参数多的兼容参数少的（参数少的可以赋值给参数多的,与接口类兼容性相反）</li><li>参数类型，相同位置的参数类型要相同（原始类型）或兼容（对象类型）</li><li>返回值类型</li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p><strong>结构化类型系统</strong>：类型检查关注的是值所具有的形状。对于对象类型来说，D 的成员至少与A 相同，则 A 兼容 D <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p></li></ol></section>`,16),c=[o];function l(i,r){return n(),a("div",null,c)}const d=s(p,[["render",l],["__file","类型兼容性.html.vue"]]);export{d as default};
